using BarbarianSim.Config;
using BarbarianSim.Enums;
using BarbarianSim.Events;
using BarbarianSim.Paragon;
using FluentAssertions;
using Moq;
using Xunit;

namespace BarbarianSim.Tests.Paragon;

public class ExploitTests
{
    private readonly Mock<SimLogger> _mockSimLogger = TestHelpers.CreateMock<SimLogger>();
    private readonly SimulationState _state = new(new SimulationConfig());
    private readonly Exploit _paragon;

    public ExploitTests()
    {
        _state.Config.ParagonNodes.Add(ParagonNode.Exploit);
        _paragon = new Exploit(_mockSimLogger.Object);
    }

    [Fact]
    public void Creates_ExploitProcEvent()
    {
        var damageEvent = new DamageEvent(123, null, 500, DamageType.Physical, DamageSource.LungingStrike, SkillType.None, _state.Enemies.First());

        _paragon.ProcessEvent(damageEvent, _state);

        _state.Events.Should().ContainSingle(e => e is ExploitProcEvent);
        _state.Events.OfType<ExploitProcEvent>().Single().Timestamp.Should().Be(123);
        _state.Events.OfType<ExploitProcEvent>().Single().Target.Should().Be(_state.Enemies.First());
    }

    [Fact]
    public void Does_Nothing_If_Paragon_Not_Active()
    {
        _state.Config.ParagonNodes.Remove(ParagonNode.Exploit);
        var damageEvent = new DamageEvent(123, null, 500, DamageType.Physical, DamageSource.LungingStrike, SkillType.None, _state.Enemies.First());

        _paragon.ProcessEvent(damageEvent, _state);

        _state.Events.Should().NotContain(e => e is ExploitProcEvent);
    }

    [Fact]
    public void Does_Nothing_If_Within_20_Seconds_Of_Previous_Proc()
    {
        var previousProc = new ExploitProcEvent(104, _state.Enemies.First());
        _state.ProcessedEvents.Add(previousProc);

        var damageEvent = new DamageEvent(123, null, 500, DamageType.Physical, DamageSource.LungingStrike, SkillType.None, _state.Enemies.First());

        _paragon.ProcessEvent(damageEvent, _state);

        _state.Events.Should().NotContain(e => e is ExploitProcEvent);
    }

    [Fact]
    public void Does_Nothing_If_Within_20_Seconds_Of_Previous_Proc_Multiple_Previous_Procs()
    {
        _state.ProcessedEvents.Add(new ExploitProcEvent(81, _state.Enemies.First()));
        _state.ProcessedEvents.Add(new ExploitProcEvent(104, _state.Enemies.First()));

        var damageEvent = new DamageEvent(123, null, 500, DamageType.Physical, DamageSource.LungingStrike, SkillType.None, _state.Enemies.First());

        _paragon.ProcessEvent(damageEvent, _state);

        _state.Events.Should().NotContain(e => e is ExploitProcEvent);
    }

    [Fact]
    public void Procs_If_More_Than_20_Seconds_Since_Last_Proc()
    {
        var previousProc = new ExploitProcEvent(102, _state.Enemies.First());
        _state.ProcessedEvents.Add(previousProc);

        var damageEvent = new DamageEvent(123, null, 500, DamageType.Physical, DamageSource.LungingStrike, SkillType.None, _state.Enemies.First());

        _paragon.ProcessEvent(damageEvent, _state);

        _state.Events.Should().ContainSingle(e => e is ExploitProcEvent);
    }

    [Fact]
    public void Considers_Target_When_Searching_For_Last_Proc()
    {
        var config = new SimulationConfig();
        config.EnemySettings.NumberOfEnemies = 2;
        var state = new SimulationState(config);
        state.Config.ParagonNodes.Add(ParagonNode.Exploit);

        var previousProc = new ExploitProcEvent(102, state.Enemies.Last());
        state.ProcessedEvents.Add(previousProc);

        var damageEvent = new DamageEvent(123, null, 500, DamageType.Physical, DamageSource.LungingStrike, SkillType.None, state.Enemies.First());

        _paragon.ProcessEvent(damageEvent, state);

        state.Events.Should().ContainSingle(e => e is ExploitProcEvent);
    }

    [Fact]
    public void Does_Nothing_Already_Proc_In_Queue()
    {
        var previousProc = new ExploitProcEvent(123, _state.Enemies.First());
        _state.Events.Add(previousProc);

        var damageEvent = new DamageEvent(123, null, 500, DamageType.Physical, DamageSource.LungingStrike, SkillType.None, _state.Enemies.First());

        _paragon.ProcessEvent(damageEvent, _state);

        _state.Events.Should().ContainSingle(e => e is ExploitProcEvent);
    }
}
